<!DOCTYPE html><html lang="en-US"><head><title>Marp CLI example</title><meta property="og:title" content="Marp CLI example"><meta property="og:image:alt" content="Marp CLI example"><meta name="description" content="Hosting Marp slide deck on the web"><meta property="og:description" content="Hosting Marp slide deck on the web"><link rel="canonical" href="https://hikmatfarhat-ndu.github.io/marp-cli-example"><meta property="og:url" content="https://hikmatfarhat-ndu.github.io/marp-cli-example"><meta property="og:image" content="https://hikmatfarhat-ndu.github.io/marp-cli-example/og-image.jpg"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta property="og:type" content="website"><meta name="twitter:card" content="summary_large_image"><style>.bespoke-marp-note,.bespoke-marp-osc,.bespoke-progress-parent{display:none;transition:none}@media screen{body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:0;color:inherit;cursor:pointer;font-size:inherit;opacity:.8;outline:none;padding:0;transition:opacity .2s linear;-webkit-tap-highlight-color:transparent}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:disabled,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:disabled,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:disabled{cursor:not-allowed;opacity:.15!important}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover{opacity:1}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:active,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:active,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover:active{opacity:.6}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:not(:disabled),body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button:hover:not(:disabled),body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button:hover:not(:disabled){transition:none}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button.bespoke-marp-presenter-info-page-prev{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSI1IiBkPSJNNjggOTBMMjggNTBsNDAtNDAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button.bespoke-marp-presenter-info-page-next{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSI1IiBkPSJNMzIgOTBsNDAtNDAtNDAtNDAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen]{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6NXB4fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJhIiB4PSIxMCIgeT0iMjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI2MCIgcng9IjUuNjciLz48cGF0aCBjbGFzcz0iYSIgZD0iTTQwIDcwSDIwVjUwbTIwIDBMMjAgNzBtNDAtNDBoMjB2MjBtLTIwIDBsMjAtMjAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button.exit[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button.exit[data-bespoke-marp-osc=fullscreen]{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6NXB4fTwvc3R5bGU+PC9kZWZzPjxyZWN0IGNsYXNzPSJhIiB4PSIxMCIgeT0iMjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI2MCIgcng9IjUuNjciLz48cGF0aCBjbGFzcz0iYSIgZD0iTTIwIDUwaDIwdjIwbS0yMCAwbDIwLTIwbTQwIDBINjBWMzBtMjAgMEw2MCA1MCIvPjwvc3ZnPg==")}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter]{background:transparent url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS13aWR0aDo1cHh9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImEiIGQ9Ik0yMCA2MGgtNWE1IDUgMCAwMS01LTVWMjBhNSA1IDAgMDE1LTVoNjBhNSA1IDAgMDE1IDV2NU0zMCA4NWg2MCIvPjxyZWN0IHg9IjMwIiB5PSIzNSIgd2lkdGg9IjYwIiBoZWlnaHQ9IjQwIiByeD0iNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZmIi8+PHJlY3QgY2xhc3M9ImEiIHg9IjMwIiB5PSIzNSIgd2lkdGg9IjYwIiBoZWlnaHQ9IjQwIiByeD0iNSIvPjxwYXRoIGNsYXNzPSJhIiBkPSJNNDAgNTBoNDBNNDAgNjBoMzAiLz48L3N2Zz4=") no-repeat 50%;background-size:contain;overflow:hidden;text-indent:100%;white-space:nowrap}body,html{height:100%;margin:0}body{background:#000;overflow:hidden}svg.bespoke-marp-slide{content-visibility:hidden;z-index:-1;pointer-events:none;opacity:0}svg.bespoke-marp-slide.bespoke-marp-active{content-visibility:visible;z-index:0;pointer-events:auto;opacity:1}svg.bespoke-marp-slide.bespoke-marp-active.bespoke-marp-active-ready *{-webkit-animation-name:__bespoke_marp__!important;animation-name:__bespoke_marp__!important}@supports not (content-visibility:hidden){svg.bespoke-marp-slide[data-bespoke-marp-load=hideable]{display:none}svg.bespoke-marp-slide[data-bespoke-marp-load=hideable].bespoke-marp-active{display:block}}[data-bespoke-marp-fragment=inactive]{visibility:hidden}body[data-bespoke-view=""] .bespoke-marp-parent,body[data-bespoke-view=next] .bespoke-marp-parent{bottom:0;left:0;position:absolute;right:0;top:0}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc{background:rgba(0,0,0,.65);border-radius:7px;bottom:50px;color:#fff;display:block;font-family:Helvetica,Arial,sans-serif;font-size:16px;left:50%;line-height:0;opacity:1;padding:12px;position:absolute;touch-action:manipulation;transform:translateX(-50%);transition:opacity .2s linear;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap;z-index:1;will-change:transform}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>*,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>*{margin-left:6px}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>:first-child,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>:first-child{margin-left:0}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>span,body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>span{opacity:.8}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>span[data-bespoke-marp-osc=page],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>span[data-bespoke-marp-osc=page]{display:inline-block;min-width:140px;text-align:center}body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=""] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=fullscreen],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=next],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=presenter],body[data-bespoke-view=next] .bespoke-marp-parent>.bespoke-marp-osc>button[data-bespoke-marp-osc=prev]{height:32px;line-height:32px;width:32px}body[data-bespoke-view=""] .bespoke-marp-parent.bespoke-marp-inactive,body[data-bespoke-view=next] .bespoke-marp-parent.bespoke-marp-inactive{cursor:none}body[data-bespoke-view=""] .bespoke-marp-parent.bespoke-marp-inactive>.bespoke-marp-osc,body[data-bespoke-view=next] .bespoke-marp-parent.bespoke-marp-inactive>.bespoke-marp-osc{opacity:0;pointer-events:none}body[data-bespoke-view=""] svg.bespoke-marp-slide,body[data-bespoke-view=next] svg.bespoke-marp-slide{height:100%;left:0;position:absolute;top:0;width:100%}body[data-bespoke-view=""] .bespoke-progress-parent{background:#222;display:flex;height:5px;width:100%}body[data-bespoke-view=""] .bespoke-progress-parent+.bespoke-marp-parent{top:5px}body[data-bespoke-view=""] .bespoke-progress-parent .bespoke-progress-bar{flex:0 0 0;background:#0288d1;transition:flex-basis .2s cubic-bezier(0,1,1,1)}body[data-bespoke-view=next]{background:transparent}body[data-bespoke-view=presenter]{background:#161616}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container{font-family:Helvetica,Arial,sans-serif;height:100%;left:0;position:absolute;top:0;width:100%;display:grid;grid-template-columns:2fr 1fr;grid-template-rows:minmax(140px,1fr) 2fr 3em;grid-template-areas:"current next" "current note" "info    note"}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent{grid-area:current;position:relative;overflow:hidden}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent svg.bespoke-marp-slide{height:calc(100% - 40px);left:20px;position:absolute;pointer-events:none;top:20px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:calc(100% - 40px)}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-parent svg.bespoke-marp-slide.bespoke-marp-active{filter:drop-shadow(0 3px 10px rgba(0,0,0,.5))}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container{background:#222;cursor:pointer;display:none;grid-area:next;overflow:hidden;position:relative}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container.active{display:block}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-next-container iframe.bespoke-marp-presenter-next{background:transparent;border:0;display:block;filter:drop-shadow(0 3px 10px rgba(0,0,0,.5));height:calc(100% - 40px);left:20px;position:absolute;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;top:20px;width:calc(100% - 40px)}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container{background:#222;color:#eee;grid-area:note}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note{margin:20px;width:calc(100% - 40px);height:calc(100% - 40px);box-sizing:border-box;font-size:1.1em;overflow:auto;padding-right:3px;white-space:pre-wrap;word-wrap:break-word;scrollbar-width:thin;scrollbar-color:hsla(0,0%,93.3%,.5) transparent}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar{width:6px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar-track{background:transparent}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note::-webkit-scrollbar-thumb{background:hsla(0,0%,93.3%,.5);border-radius:6px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note:empty{pointer-events:none}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note.active{display:block}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note p:first-child{margin-top:0}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-note-container .bespoke-marp-note p:last-child{margin-bottom:0}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container{align-items:center;box-sizing:border-box;color:#eee;display:flex;flex-wrap:nowrap;grid-area:info;justify-content:center;padding:0 10px}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-time,body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-timer{display:block;box-sizing:border-box;padding:0 10px;white-space:nowrap;width:100%}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container button{height:1.5em;line-height:1.5em;width:1.5em}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page{order:2;text-align:center}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-page .bespoke-marp-presenter-info-page-text{display:inline-block;min-width:120px;text-align:center}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-time{color:#999;order:1;text-align:left}body[data-bespoke-view=presenter] .bespoke-marp-presenter-container .bespoke-marp-presenter-info-container .bespoke-marp-presenter-info-timer{color:#999;order:3;text-align:right}}@media print{.bespoke-marp-presenter-info-container,.bespoke-marp-presenter-next-container,.bespoke-marp-presenter-note-container{display:none}}</style><style>div#p>svg>foreignObject>section{width:1280px;height:720px;box-sizing:border-box;overflow:hidden;position:relative;scroll-snap-align:center center}div#p>svg>foreignObject>section:after{bottom:0;content:attr(data-marpit-pagination);padding:inherit;pointer-events:none;position:absolute;right:0}div#p>svg>foreignObject>section:not([data-marpit-pagination]):after{display:none}/* Normalization */div#p>svg>foreignObject>section h1{font-size:2em;margin:0.67em 0}div#p>svg>foreignObject>section video::-webkit-media-controls{will-change:transform}@page{size:1280px 720px;margin:0}@media print{body,html{background-color:#fff;margin:0;page-break-inside:avoid;break-inside:avoid-page}div#p>svg>foreignObject>section{page-break-before:always;break-before:page}div#p>svg>foreignObject>section,div#p>svg>foreignObject>section *{-webkit-print-color-adjust:exact!important;animation-delay:0s!important;animation-duration:0s!important;color-adjust:exact!important;transition:none!important}div#p>svg[data-marpit-svg]{display:block;height:100vh;width:100vw}}div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{display:block;height:auto;width:100%}@supports (-ms-ime-align:auto){div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{position:static}}div#p>svg>foreignObject>section svg[data-marp-fitting=svg].__reflow__{content:""}@supports (-ms-ime-align:auto){div#p>svg>foreignObject>section svg[data-marp-fitting=svg].__reflow__{position:relative}}div#p>svg>foreignObject>section [data-marp-fitting-svg-content]{display:table;white-space:nowrap}div#p>svg>foreignObject>section [data-marp-fitting-svg-content-wrap]{white-space:pre}div#p>svg>foreignObject>section img[data-marp-twemoji]{background:transparent;height:1em;margin:0 .05em 0 .1em;vertical-align:-.1em;width:1em}
/*!
 * Marp / Marpit Uncover theme
 *
 * @theme uncover
 * @author Yuki Hattori
 *
 * @auto-scaling fittingHeader,math
 * @size 4:3 960px 720px
 */div#p>svg>foreignObject>section{display:flex;flex-direction:column;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;flex-wrap:nowrap;font-size:40px;height:720px;justify-content:center;letter-spacing:3px;line-height:1.4;padding:30px 70px;position:relative;text-align:center;width:1280px;word-wrap:break-word;z-index:0;background:#fdfcff;color:#202228}div#p>svg>foreignObject>section{--marpit-root-font-size:40px}div#p>svg>foreignObject>section:after{align-items:flex-end;display:flex;font-size:.6em;height:80px;justify-content:flex-end;padding:30px;text-align:right;width:80px;background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1 1" width="1" height="1"><path d="M0 1h1v-1Z" fill="rgba(32, 34, 40, 0.05)"/></svg>') no-repeat 50%;background-size:cover;color:#202228;text-shadow:0 0 5px #fdfcff}div#p>svg>foreignObject>section:after{--marpit-root-font-size:.6em}div#p>svg>foreignObject>section code,div#p>svg>foreignObject>section pre{background:#f2f1f4;color:#202228}div#p>svg>foreignObject>section a{color:#009dd5}div#p>svg>foreignObject>section a:hover{color:#087eaa}div#p>svg>foreignObject>section h1 strong,div#p>svg>foreignObject>section h2 strong,div#p>svg>foreignObject>section h3 strong,div#p>svg>foreignObject>section h4 strong,div#p>svg>foreignObject>section h5 strong,div#p>svg>foreignObject>section h6 strong{color:#33b1dd}div#p>svg>foreignObject>section footer,div#p>svg>foreignObject>section header{color:rgba(32,34,40,.4);text-shadow:0 1px 0 rgba(253,252,255,.8)}div#p>svg>foreignObject>section mark{color:#009dd5;background:transparent}div#p>svg>foreignObject>section:not(.invert) .hljs{display:block;overflow-x:auto;padding:.5em;background:#fff}div#p>svg>foreignObject>section:not(.invert) .hljs,div#p>svg>foreignObject>section:not(.invert) .hljs-subst{color:#000}div#p>svg>foreignObject>section:not(.invert) .hljs-addition,div#p>svg>foreignObject>section:not(.invert) .hljs-meta,div#p>svg>foreignObject>section:not(.invert) .hljs-string,div#p>svg>foreignObject>section:not(.invert) .hljs-symbol,div#p>svg>foreignObject>section:not(.invert) .hljs-template-tag,div#p>svg>foreignObject>section:not(.invert) .hljs-template-variable{color:#756bb1}div#p>svg>foreignObject>section:not(.invert) .hljs-comment,div#p>svg>foreignObject>section:not(.invert) .hljs-quote{color:#636363}div#p>svg>foreignObject>section:not(.invert) .hljs-bullet,div#p>svg>foreignObject>section:not(.invert) .hljs-link,div#p>svg>foreignObject>section:not(.invert) .hljs-literal,div#p>svg>foreignObject>section:not(.invert) .hljs-number,div#p>svg>foreignObject>section:not(.invert) .hljs-regexp{color:#31a354}div#p>svg>foreignObject>section:not(.invert) .hljs-deletion,div#p>svg>foreignObject>section:not(.invert) .hljs-variable{color:#88f}div#p>svg>foreignObject>section:not(.invert) .hljs-built_in,div#p>svg>foreignObject>section:not(.invert) .hljs-doctag,div#p>svg>foreignObject>section:not(.invert) .hljs-keyword,div#p>svg>foreignObject>section:not(.invert) .hljs-name,div#p>svg>foreignObject>section:not(.invert) .hljs-section,div#p>svg>foreignObject>section:not(.invert) .hljs-selector-class,div#p>svg>foreignObject>section:not(.invert) .hljs-selector-id,div#p>svg>foreignObject>section:not(.invert) .hljs-selector-tag,div#p>svg>foreignObject>section:not(.invert) .hljs-strong,div#p>svg>foreignObject>section:not(.invert) .hljs-tag,div#p>svg>foreignObject>section:not(.invert) .hljs-title,div#p>svg>foreignObject>section:not(.invert) .hljs-type{color:#3182bd}div#p>svg>foreignObject>section:not(.invert) .hljs-emphasis{font-style:italic}div#p>svg>foreignObject>section:not(.invert) .hljs-attribute{color:#e6550d}div#p>svg>foreignObject>section.invert{background:#202228;color:#fff}div#p>svg>foreignObject>section.invert:after{background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1 1" width="1" height="1"><path d="M0 1h1v-1Z" fill="rgba(255, 255, 255, 0.05)"/></svg>') no-repeat 50%;background-size:cover;color:#fff;text-shadow:0 0 5px #202228}div#p>svg>foreignObject>section.invert code,div#p>svg>foreignObject>section.invert pre{background:#2b2d33;color:#fff}div#p>svg>foreignObject>section.invert a{color:#60d0f0}div#p>svg>foreignObject>section.invert a:hover{color:#88dcf4}div#p>svg>foreignObject>section.invert h1 strong,div#p>svg>foreignObject>section.invert h2 strong,div#p>svg>foreignObject>section.invert h3 strong,div#p>svg>foreignObject>section.invert h4 strong,div#p>svg>foreignObject>section.invert h5 strong,div#p>svg>foreignObject>section.invert h6 strong{color:#80d9f3}div#p>svg>foreignObject>section.invert footer,div#p>svg>foreignObject>section.invert header{color:hsla(0,0%,100%,.4);text-shadow:0 1px 0 rgba(32,34,40,.8)}div#p>svg>foreignObject>section.invert mark{color:#60d0f0;background:transparent}div#p>svg>foreignObject>section.invert .hljs{display:block;overflow-x:auto;padding:.5em;background:#222;color:#fff}div#p>svg>foreignObject>section.invert .hljs-comment,div#p>svg>foreignObject>section.invert .hljs-quote{color:#777}div#p>svg>foreignObject>section.invert .hljs-built_in,div#p>svg>foreignObject>section.invert .hljs-builtin-name,div#p>svg>foreignObject>section.invert .hljs-bullet,div#p>svg>foreignObject>section.invert .hljs-deletion,div#p>svg>foreignObject>section.invert .hljs-link,div#p>svg>foreignObject>section.invert .hljs-literal,div#p>svg>foreignObject>section.invert .hljs-meta,div#p>svg>foreignObject>section.invert .hljs-number,div#p>svg>foreignObject>section.invert .hljs-params,div#p>svg>foreignObject>section.invert .hljs-regexp,div#p>svg>foreignObject>section.invert .hljs-symbol,div#p>svg>foreignObject>section.invert .hljs-tag,div#p>svg>foreignObject>section.invert .hljs-template-variable,div#p>svg>foreignObject>section.invert .hljs-variable{color:#ab875d}div#p>svg>foreignObject>section.invert .hljs-attribute,div#p>svg>foreignObject>section.invert .hljs-name,div#p>svg>foreignObject>section.invert .hljs-section,div#p>svg>foreignObject>section.invert .hljs-selector-class,div#p>svg>foreignObject>section.invert .hljs-selector-id,div#p>svg>foreignObject>section.invert .hljs-title,div#p>svg>foreignObject>section.invert .hljs-type{color:#9b869b}div#p>svg>foreignObject>section.invert .hljs-addition,div#p>svg>foreignObject>section.invert .hljs-keyword,div#p>svg>foreignObject>section.invert .hljs-selector-tag,div#p>svg>foreignObject>section.invert .hljs-string{color:#8f9c6c}div#p>svg>foreignObject>section.invert .hljs-emphasis{font-style:italic}div#p>svg>foreignObject>section.invert .hljs-strong{font-weight:700}div#p>svg>foreignObject>section>:first-child,div#p>svg>foreignObject>section[data-header]>:nth-child(2){margin-top:0}div#p>svg>foreignObject>section>:last-child,div#p>svg>foreignObject>section[data-footer]>:nth-last-child(2){margin-bottom:0}div#p>svg>foreignObject>section svg[data-marp-fitting=svg]{max-height:660px;--preserve-aspect-ratio:xMidYMid meet}div#p>svg>foreignObject>section blockquote,div#p>svg>foreignObject>section p{margin:0 0 15px}div#p>svg>foreignObject>section h1,div#p>svg>foreignObject>section h2,div#p>svg>foreignObject>section h3,div#p>svg>foreignObject>section h4,div#p>svg>foreignObject>section h5,div#p>svg>foreignObject>section h6{margin:15px 0 30px}div#p>svg>foreignObject>section h1 strong,div#p>svg>foreignObject>section h2 strong,div#p>svg>foreignObject>section h3 strong,div#p>svg>foreignObject>section h4 strong,div#p>svg>foreignObject>section h5 strong,div#p>svg>foreignObject>section h6 strong{font-weight:inherit}div#p>svg>foreignObject>section h1{font-size:2em}div#p>svg>foreignObject>section h2{font-size:1.7em}div#p>svg>foreignObject>section h3{font-size:1.4em;letter-spacing:2px}div#p>svg>foreignObject>section h4{font-size:1.2em;letter-spacing:2px}div#p>svg>foreignObject>section h5{font-size:1em;letter-spacing:1px}div#p>svg>foreignObject>section h6{font-size:.8em;letter-spacing:1px}div#p>svg>foreignObject>section footer,div#p>svg>foreignObject>section header{position:absolute;z-index:1;left:70px;right:70px;font-size:.45em;letter-spacing:1px}div#p>svg>foreignObject>section header{top:30px}div#p>svg>foreignObject>section footer{bottom:30px}div#p>svg>foreignObject>section a{text-decoration:none}div#p>svg>foreignObject>section a:hover{text-decoration:underline}div#p>svg>foreignObject>section ol,div#p>svg>foreignObject>section ul{margin:0 auto;text-align:left}div#p>svg>foreignObject>section>ol,div#p>svg>foreignObject>section>ul{margin-bottom:15px}div#p>svg>foreignObject>section code,div#p>svg>foreignObject>section pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;letter-spacing:0;margin:-.2em .2em .2em;padding:.2em}div#p>svg>foreignObject>section pre{box-shadow:0 4px 8px rgba(0,0,0,.2);font-size:70%;line-height:1.15;margin:15px auto 30px;min-width:40%;padding:.4em .6em;text-align:left}div#p>svg>foreignObject>section pre>code{margin:0;padding:0}div#p>svg>foreignObject>section table{border-collapse:collapse;margin:0 auto 15px}div#p>svg>foreignObject>section table>tbody>tr>td,div#p>svg>foreignObject>section table>tbody>tr>th,div#p>svg>foreignObject>section table>thead>tr>td,div#p>svg>foreignObject>section table>thead>tr>th{padding:.15em .5em}div#p>svg>foreignObject>section table>thead>tr>td,div#p>svg>foreignObject>section table>thead>tr>th{border-bottom:3px solid}div#p>svg>foreignObject>section table>tbody>tr:not(:last-child)>td,div#p>svg>foreignObject>section table>tbody>tr:not(:last-child)>th{border-bottom:1px solid}div#p>svg>foreignObject>section blockquote{font-size:90%;line-height:1.3;padding:0 2em;position:relative;z-index:0}div#p>svg>foreignObject>section blockquote:after,div#p>svg>foreignObject>section blockquote:before{content:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNDQgMTkuM0wzOC45NCAwQzguMTQgOS41OSAwIDQwLjA1IDAgNTQuODNWMTAwaDQxLjQ3VjU0LjgzaC0yM2MtLjA0LS4yOC4yNS0yNy42NiAyNS41My0zNS41M3ptNTYgMEw5NC45NCAwQzY0LjE0IDkuNTkgNTYgNDAuMDUgNTYgNTQuODNWMTAwaDQxLjQ3VjU0LjgzaC0yM2MtLjA0LS4yOC4yNS0yNy42NiAyNS41My0zNS41M3oiIGZpbGw9IiM4ODgiIG9wYWNpdHk9Ii4zMyIvPjwvc3ZnPg==");height:auto;pointer-events:none;position:absolute;width:1em;z-index:-1}div#p>svg>foreignObject>section blockquote:before{left:0;top:0}div#p>svg>foreignObject>section blockquote:after{bottom:0;right:0;transform:rotate(180deg)}div#p>svg>foreignObject>section blockquote>:last-child{margin-bottom:0}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]{display:block!important;padding:0!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]:after,div#p>svg>foreignObject>section[data-marpit-advanced-background=background]:before,div#p>svg>foreignObject>section[data-marpit-advanced-background=content]:after,div#p>svg>foreignObject>section[data-marpit-advanced-background=content]:before{display:none!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container]{all:initial;display:flex;flex-direction:row;height:100%;overflow:hidden;width:100%}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container][data-marpit-advanced-background-direction=vertical]{flex-direction:column}div#p>svg>foreignObject>section[data-marpit-advanced-background=background][data-marpit-advanced-background-split]>div[data-marpit-advanced-background-container]{width:var(--marpit-advanced-background-split,50%)}div#p>svg>foreignObject>section[data-marpit-advanced-background=background][data-marpit-advanced-background-split=right]>div[data-marpit-advanced-background-container]{margin-left:calc(100% - var(--marpit-advanced-background-split, 50%))}div#p>svg>foreignObject>section[data-marpit-advanced-background=background]>div[data-marpit-advanced-background-container]>figure{all:initial;background-position:center;background-repeat:no-repeat;background-size:cover;flex:auto;margin:0}div#p>svg>foreignObject>section[data-marpit-advanced-background=content],div#p>svg>foreignObject>section[data-marpit-advanced-background=pseudo]{background:transparent!important}div#p>svg>foreignObject>section[data-marpit-advanced-background=pseudo],div#p>svg[data-marpit-svg]>foreignObject[data-marpit-advanced-background=pseudo]{pointer-events:none!important}div#p>svg>foreignObject>section[data-marpit-advanced-background-split]{width:100%;height:100%}</style></head><body><div class="bespoke-marp-osc"><button data-bespoke-marp-osc="prev" tabindex="-1" title="Previous slide">Previous slide</button><span data-bespoke-marp-osc="page"></span><button data-bespoke-marp-osc="next" tabindex="-1" title="Next slide">Next slide</button><button data-bespoke-marp-osc="fullscreen" tabindex="-1" title="Toggle fullscreen (f)">Toggle fullscreen</button><button data-bespoke-marp-osc="presenter" tabindex="-1" title="Open presenter view (p)">Open presenter view</button></div><div id="p"><svg data-marpit-svg="" viewBox="0 0 1280 720"><foreignObject width="1280" height="720"><section id="1" data-theme="uncover" style="--theme:uncover;">
<h1>Multithreading in  C++. Part 1.</h1>
<p>Starting with the C++11 standard, C++ provides support for writing <em>portable</em> multitheaded applications without relying on additional libraries and extensions. The basic functions and classes for thread support are declared in the <code>&lt;thread&gt;</code> header. Check the definition  <a href="https://en.cppreference.com/w/cpp/thread/thread">here</a>.<br />
We introduce threads with the ubiquitous hello thread program.</p>
<h1>Creating threads</h1>
<p>Starting a new thead in C++ is done by constructing a new <code>std::thread</code> object. Thread execution begins <strong>immediately</strong> after the <code>thread</code> object is constructed. A simple example,</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>

<span class="hljs-comment">// every thread has an &quot;entry&quot; function</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello thread\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(hello)</span></span>;
    t.join();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre>
<p>Thread execution starts at the <strong>entry</strong> or <strong>top level</strong> function passed as an argument to the thread object constructor. In the example above the <strong>entry</strong> or <strong>top level</strong> function is <code>hello()</code>.<br />
Since the return value of the <strong>top level</strong> function is ignore it is usually returns void.<br />
The Note that the program now has <strong>two</strong> threads, the initial one running <code>main()</code> and the one we have created. The call to <code>join()</code> is important, otherwise the main thread could finish before the thread <code>t</code>.<br />
Note that we can choose <code>detach()</code> instead of <code>join()</code>. In this case the thread would continue even after the main thread finished. In either case, we need to choose one of the two options, otherwise when the thread destructor is called it terminates our program. Almost in all use cases we use <code>join()</code>.</p>
<h1>Function Objects and Lambdas</h1>
<p>In addition to functions, threads can be passed function objects or lambdas as parameters. For example</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bg_task</span>{</span>

   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">()</span></span>{
     <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;function object \n&quot;</span>;
   }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">a</span><span class="hljs-params">(bg_task{})</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">b</span><span class="hljs-params">([](){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;calling lambda\n&quot;</span>;
    })</span></span>;
a.join();
b.join();

}
</code></pre>
<p>You can try this simple example <a href="https://godbolt.org/z/b3TcYe">here</a>. Note that when using gcc we need to pass the pthread switch.</p>
<p>So far we have used <code>std::thread::join</code> which we use almost exclusively. The example below is an illustration of the use of <code>detach</code>.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WAIT</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_to_file</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-built_in">std</span>::ofstream output;
	output.open(<span class="hljs-string">&quot;output.txt&quot;</span>);
	output &lt;&lt; <span class="hljs-string">&quot;first line\n&quot;</span>;
	output &lt;&lt; <span class="hljs-string">&quot;second line\n&quot;</span>;
	output.close();
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">std</span>::thread t{ write_to_file };
	t.detach();
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WAIT</span>
	<span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-built_in">std</span>::chrono::minutes(<span class="hljs-number">1</span>));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</code></pre>
<p>As you can see we use <code>detach()</code> instead of <code>join()</code>. Therefore the calling thread (in this case main) does not wait for the thread <code>t</code>. But when the main thread exists all other threads are destroyed. Therefore the created thread might not have enough time to perform its job. You can see these two cases by defining and undefining  <strong>WAIT</strong> in the code.</p>
<h1>In class exercise 0</h1>
<p>Write two function, each running in its own thead. The first <code>read_input</code> keeps reading input from <code>std::cin</code> until the user types &quot;quit&quot;. The second one,<code>read_file</code> reads the content of (a one line) file. To simulate a time consuming I/O operations the <code>read_file</code> function should sleep for 10 seconds.<br />
Create a text file in the same directory as your VC++ solution, call it &quot;input.txt&quot; and write a one liner in it.</p>
<pre><code class="language-cpp">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_input</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;enter a string. Type &#x27;quit&#x27; to quit\n&quot;</span>;
    <span class="hljs-keyword">while</span> (s != <span class="hljs-string">&quot;quit&quot;</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; s;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;user input= &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

    }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name)</span> </span>{
    <span class="hljs-built_in">std</span>::ifstream file;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> content;
    <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-built_in">std</span>::chrono::seconds(<span class="hljs-number">10</span>));
    file.open(name);
    <span class="hljs-built_in">std</span>::getline(file, content);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;content of file =&quot;</span> &lt;&lt; content &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    file.close();
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(read_file,<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t2</span><span class="hljs-params">(read_input)</span></span>;
    t.join();
    t2.join();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;main thread done\n&quot;</span>;
}


</code></pre>
<h1>Handling exceptions</h1>
<p>We close this section by considering the case when an <strong>exception</strong> is thrown before a thread is joined. Consider the following code</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myf</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::exception{};
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runt</span><span class="hljs-params">()</span></span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">([](){<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;started thread\n&quot;</span>;})</span></span>;
    myf();
    t.join();

}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">try</span> {
        runt();
    }
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">std</span>::exception e){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;main thread is done\n&quot;</span>;
}
</code></pre>
<p>Try running this code <a href="https://godbolt.org/z/K3a96M">here</a>.<br />
As you can see the statement <code>std::cout&lt;&lt;&quot;main thread is done\n&quot;</code> is never reached. This is because when the destructor of a thread object is called (i.e. ~std::thread()) it calls <code>std::terminate()</code> <strong>if</strong> the thread is <strong>joinable</strong>. Calling <code>std::thread::join()</code> or <code>std::thread::detach()</code> make the thread <strong>not joinable</strong> and therefore does not call <code>std::terminate()</code>.</p>
<p>In the above example, <code>t.join()</code> is never reached because <code>myf()</code> throws an exception. Therefore  <code>t.~thread()</code> calls <code>std::terminate()</code>.<br />
One way to guard against such a situation to use the <em>Resource acquisition is initialization</em> (RAII) technique. We will see more of this technique when we study mutexes and locks but for now it is sufficient to say that we construct an object wrapper around the thread so that it automatically calls <code>join()</code> when it is destroyed.</p>
<p>In the code below we define a class <code>thread_guard</code> that <strong>automatically</strong> calls <code>join</code> when its destructor is called. Since the destructor is called when the object goes out of scope this guarantees that the created thread will be joined even when the scope that created the thread takes an unexpected flow due to exceptions.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">()</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwf</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;starting throwf\n&quot;</span>;
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::exception{  };
}
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_guard</span> {</span>
    <span class="hljs-built_in">std</span>::thread&amp; <span class="hljs-keyword">_t</span>;

    thread_guard(<span class="hljs-built_in">std</span>::thread&amp; t) :<span class="hljs-keyword">_t</span>(t) { }
    ~thread_guard() {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">_t</span>.joinable())
            <span class="hljs-keyword">_t</span>.join();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;thread guard dtor\n&quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runt</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf)</span></span>;
    <span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;
    throwf();
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">try</span> {
        runt();
    }
    <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">std</span>::exception &amp; e) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;main thread is done\n&quot;</span>;
}
</code></pre>
<p>You can try the above code <a href="https://godbolt.org/z/8MG91T">here</a></p>
<p>Our solution <strong>does not</strong> guard against the case when an exception occurs <strong>inside</strong> the thread code. In the previous example if the thread <em>t</em> runs function <code>throwf</code> instead of <code>threadf</code> our thread_guard solution does not work. This is because exceptions <strong>are not</strong> transferred between threads so we need to handle it locally. One solution is to provide an exception safe wrapper as in the example below.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">()</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwf</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;starting throwf\n&quot;</span>;
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::exception{  };
}
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_guard</span> {</span>
    <span class="hljs-built_in">std</span>::thread&amp; <span class="hljs-keyword">_t</span>;

    thread_guard(<span class="hljs-built_in">std</span>::thread&amp; t) :<span class="hljs-keyword">_t</span>(t) { }
    ~thread_guard() {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">_t</span>.joinable())
            <span class="hljs-keyword">_t</span>.join();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;thread guard dtor\n&quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runt</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(throwf)</span></span>;
    <span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;
    throwf();
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(F f)</span></span>{
   <span class="hljs-keyword">try</span>{
       f();
   }
   <span class="hljs-keyword">catch</span>(...){}
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(wrapper&lt;<span class="hljs-keyword">void</span> (*)()&gt;,throwf)</span></span>;
    t.join();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;main thread is done\n&quot;</span>;
}
</code></pre>
<p>You can try the code <a href="https://godbolt.org/z/Gqbvvj">here</a>.</p>
<p>In this case the compiler can not automatically deduce the template parameter type <code>F</code> because we are calling <code>wrapper</code> indirectly inside a thread object. Compare that with just calling from main <code>wrapper(throwf)</code> which the compiler can automatically deduce.</p>
<p>If passing the type of <code>throwf</code> to the template looks complicated you can use <code>decltype</code>, i.e.<br />
<code>std::thread t(wrapper&lt;decltype(throwf)&gt;,throwf)</code></p>
<h1>Passing parameters</h1>
<p>Passing arguments to the function is done by passing extra arguments to the thread constructor.<br />
For example,</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fobj</span>{</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s)</span></span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s)</span></span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">q</span><span class="hljs-params">(fobj{},<span class="hljs-string">&quot;Hello function object&quot;</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">p</span><span class="hljs-params">([](<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
        },<span class="hljs-string">&quot;Hello lambda&quot;</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf,<span class="hljs-string">&quot;hello function&quot;</span>)</span></span>;
    p.join();
    q.join();
    t.join();
}
</code></pre>
<p>You can try the above code <a href="https://godbolt.org/z/oTaYxn">here</a>.</p>
<p>Internally, the thread constructor passes arguments to the callable object as an <strong>rvalue</strong>.<br />
Therefore if the callable object expects the argument to be a reference then use <code>std::ref</code>.</p>
<p>The code below will not compile</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x)</span></span>{
    x=<span class="hljs-number">17</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf,x)</span></span>;
    t.join();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
<p>But this one does, <strong>note</strong> the use of <code>std::ref</code>.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x)</span></span>{
    x=<span class="hljs-number">17</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf,<span class="hljs-built_in">std</span>::ref(x))</span></span>;
    t.join();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
<p>Try it <a href="https://godbolt.org/z/63aWsb">here</a>.</p>
<p>The situation is similar to the following example:</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>{

}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T f,U&amp;&amp; x)</span></span>{
    f(<span class="hljs-built_in">std</span>::move(x));
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">17</span>;
    g(func,x);
}
</code></pre>
<p>You can try it <a href="https://godbolt.org/z/Mv9ddq">here</a>.</p>
<p>A different way of passing parameters by reference would be to use a function object that stores a reference to the variable.<br />
Example</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> {</span>
	<span class="hljs-keyword">int</span>&amp; _x;
	foo(<span class="hljs-keyword">int</span>&amp; x) :_x(x) {}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>{
		_x = <span class="hljs-number">19</span>;
	}
};
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">8</span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(foo{x})</span></span>;
    t.join();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<h1>In class exercise 1</h1>
<p>In this exercise we use two threads to generate  two large random prime numbers.<br />
We compare the performance with a sequential version where the generator is called twice in a row.</p>
<p>First we write the random number generator and the selection of primes</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-comment">/* a simple function to sample large random numbers */</span>
<span class="hljs-built_in">std</span>::random_device rd;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> lowest=<span class="hljs-number">4000000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> highest=<span class="hljs-number">8000000</span>;
<span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(lowest, highest)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_rand</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> dist(rd);
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
      <span class="hljs-comment">/* this is NOT the most efficient way of
      * determining if a number is prime */</span>
    <span class="hljs-keyword">if</span> (value &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; value; ++i) 
        <span class="hljs-keyword">if</span> (value % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

</code></pre>
<p>The above allows us to generate a random number between <em>lowest</em> and <em>highest</em> then test if it is a prime number. Note that <code>is_prime()</code> is <strong>not</strong> the most efficient way of testing a prime. In any case we prefer this so that each thread has sufficiently large computations to perform.</p>
<p>To have enough probability to select a prime we repeat the above <em>n</em> times until we find a prime number as shown below.</p>
<pre><code class="language-cpp"><span class="hljs-comment">/* A function that samples random numbers until it finds a prime.
* Gives up and returns 0 after n tries
*/</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_large_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">int</span> large;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        large = get_rand();
        <span class="hljs-keyword">if</span> (is_prime(large))<span class="hljs-keyword">return</span> large;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>We call the above code twice, sequentially, and measure the duration.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num_tries = <span class="hljs-number">300</span>;
    <span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">int</span> v1,v2;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;starting sequential\n&quot;</span>;
    v1=get_large_prime(num_tries);
    v2 = get_large_prime(num_tries);
    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> duration = <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>&gt;&gt;(end - start);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;values found &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;sequential time = &quot;</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
<p>On an i7 this takes about 26 milliseconds.</p>
<p>To perform the two operations in parallel, since we have multiple cores, we run <code>get_large_prime</code> in two separate threads. Since a <code>std::thread</code> object ignores the return value of the top level function we must pass a variable by reference to retrieve the prime number. Therefore we overload <code>get_large_prime</code> as follows:</p>
<pre><code class="language-cpp"><span class="hljs-comment">/* to be used with threads */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_large_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span>&amp; result)</span> </span>{
    <span class="hljs-keyword">int</span> large;
    result=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        large = get_rand();
        <span class="hljs-keyword">if</span> (is_prime(large)){
            result=large;
            <span class="hljs-keyword">return</span> ;
        }
    }
    <span class="hljs-keyword">return</span> ;
}

</code></pre>
<p>And the main function</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num_tries = <span class="hljs-number">300</span>;
    <span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">int</span> v1,v2;
    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; starting two threads \n&quot;</span>;
    <span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-comment">/* start two threads here and call the
    * the function you wrote to get a large prime
    */</span>
   
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t1</span><span class="hljs-params">(get_large_prime,num_tries, <span class="hljs-built_in">std</span>::ref(v1))</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t2</span><span class="hljs-params">(get_large_prime,num_tries, <span class="hljs-built_in">std</span>::ref(v2))</span></span>;
    t1.join(); t2.join();
    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> duration = <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>&gt;&gt;(end - start);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;values found &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;two threads time = &quot;</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
</code></pre>
<p>Unfortunately, with threads the compiler doesn't know which version to use. You can try the above [here] (<a href="https://godbolt.org/z/jWhjqK">https://godbolt.org/z/jWhjqK</a>) to see the error.</p>
<p>The simplest solution is to give a different name for the two versions. A different way is to help the compiler which allows us to use the same name.</p>
<pre><code class="language-cpp">...
 <span class="hljs-keyword">using</span> FType = <span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&amp;);
 FType f = get_large_prime;
 <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t1</span><span class="hljs-params">(f,num_tries, <span class="hljs-built_in">std</span>::ref(v1))</span></span>;
 <span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t2</span><span class="hljs-params">(f)</span>,num_tries, <span class="hljs-title">std::ref</span><span class="hljs-params">(v2)</span>)</span>;
 ...
</code></pre>
<p>You can try this solution <a href="https://godbolt.org/z/sadPTj">here</a>.</p>
<h1>Transferring thread ownership</h1>
<p>Sometimes we need to transfer ownership of thread. For example, we we need to store threads in containers. But thread objects are <strong>not copyable</strong>. Only one thread object can be associated with a thread of execution at any given time. In these cases we must use <strong>move semantics</strong>.<br />
Here an example to illustrate the problem. For simplicity we define a <code>Container</code> class that holds a single item. Typically, a container would add a <strong>copy</strong> of an object of arbitrary type which does not work with threads.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span> {</span>
	T <span class="hljs-keyword">_t</span>;
	Container() {
		<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;general\n&quot;</span>;
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t)</span> </span>{
		<span class="hljs-keyword">_t</span> = t;
	}
	<span class="hljs-function">T&amp; <span class="hljs-title">getItem</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">_t</span>;
	}
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tclass</span>{</span>
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{

	<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf)</span></span>;
	Tclass obj;
	Container&lt;<span class="hljs-built_in">std</span>::thread&gt; tc;
	Container&lt;Tclass&gt; oc;
	tc.addItem(t);
	oc.addItem(obj);
	
	tc.getItem().join();
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;main thread is done\n&quot;</span>;
}
</code></pre>
<p>If you run the above code <a href="https://godbolt.org/z/7TMvWT">here</a> the compiler will give an error similar to &quot;use of deleted function operator=&quot; because it is deleted for <code>std::tread</code> objects.<br />
One solution would be to <strong>specialize</strong> the template for <code>Container</code>, i.e. add the following code</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span>&lt;</span><span class="hljs-built_in">std</span>::thread&gt; {
	<span class="hljs-built_in">std</span>::thread <span class="hljs-keyword">_t</span>;
	Container() {
		<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;specialized\n&quot;</span>;
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::thread&amp; t)</span> </span>{
		<span class="hljs-keyword">_t</span> = <span class="hljs-built_in">std</span>::move(t);
		
	}
	<span class="hljs-function"><span class="hljs-built_in">std</span>::thread &amp; <span class="hljs-title">getItem</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">_t</span>;
	}
	
};
</code></pre>
<p>As you can see the <code>addItem</code> method uses <code>std::move</code> when <code>T=std::thread</code>.<br />
A better method which is used by STL containers is to have two versions of <code>addItem</code>: one that takes a constant reference and the other an rvalue reference as show in the code below.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadf</span><span class="hljs-params">()</span> </span>{
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span> {</span>
	T <span class="hljs-keyword">_t</span>;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(T&amp; t)</span> </span>{
		<span class="hljs-keyword">_t</span> = t;
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>{
		<span class="hljs-keyword">_t</span> = <span class="hljs-built_in">std</span>::move(t);
	}
	<span class="hljs-function">T&amp; <span class="hljs-title">getItem</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">_t</span>;
	}
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tclass</span>{</span>
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{

	<span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t</span><span class="hljs-params">(threadf)</span></span>;
	Tclass obj;
	Container&lt;<span class="hljs-built_in">std</span>::thread&gt; tc;
	Container&lt;Tclass&gt; oc;

	tc.addItem(<span class="hljs-built_in">std</span>::move(t));
	oc.addItem(obj);
	
	tc.getItem().join();
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;main thread is done\n&quot;</span>;
}
</code></pre>
<p>You can test the code <a href="https://godbolt.org/z/EsEWb7">here</a></p>
<h1>In class exercise 2 (Note on compiler optimization)</h1>
<p>In many of the examples we compare the performance of single vs multi threaded versions. Since our focus is on performance we don't use the result of the single threaded version unless we need to check the correctness of the multi-threaded version.</p>
<p>This approach sometimes leads to surprising results because of <strong>compiler optimizations</strong>. In particular, <strong>dead code elimination</strong>.<br />
The basic idea is that if a variable or the output of a function is not used, the compiler might not include the function in the executable. In that case the duration of the function call is (close to) zero.</p>
<p>Let us illustrate with an example of sequential code.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">std</span>::random_device rd;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)</span></span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n=<span class="hljs-number">5000000</span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-built_in">std</span>::generate(v.begin(),v.end(),[&amp;](){<span class="hljs-keyword">return</span> dist(rd);});
    <span class="hljs-keyword">auto</span> start=<span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">bool</span> result=<span class="hljs-built_in">std</span>::any_of(v.begin(),v.end(),
            [](<span class="hljs-keyword">int</span> x){<span class="hljs-keyword">return</span> x==<span class="hljs-number">2000</span>;}
            );
    <span class="hljs-keyword">auto</span> end=<span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> duration=
        <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>,<span class="hljs-built_in">std</span>::milli&gt;(end-start);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;duration = &quot;</span>&lt;&lt;duration.count()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;value found =&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::boolalpha&lt;&lt;result&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p>You can try the above code <a href="https://godbolt.org/z/voTvna">here</a><br />
The duration is either close to zero or about 2.3 milliseconds depending on if<br />
we remove the last line that prints the value of <code>result</code> or not.</p>
<p>The reason is that when we don't print (i.e. not use) the variable result the compiler removes it from the code. This can be seen below in the assembly output between the two calls to <code>now()</code>.</p>
<p><img src="figs/asm2.jpg" alt="Figure 1" /></p>
<p><img src="figs/asm1.jpg" alt="Figure 2" /></p>
<p>Figure 1  shows the assembly output when the last line <strong>is not included</strong>. Note the absence of instructions between the two calls to <code>now()</code>.</p>
<p>Figure 2  shows the assembly output when the last line <strong>is included</strong>. Note the number of instructions between the two calls to <code>now()</code>.</p>
<h1>In class exercise 3</h1>
<p>In this exercise we will build a multi-threaded program to determine if a large vector of integers contains a certain value.</p>
<p>This is the parallel version of STL <code>std::any_of</code>( we will see later that STL algorithms can also be parallelized easily)</p>
<p>The basic idea is to divide the range into as many blocks  as there are hardware threads. For each block, a thread, independently, searches that block for the value.<br />
When all the threads are done, if any of them as found a value in its own block we conclude that the vector contains that value.<br />
To collect the results of threads we define <code>std::vector&lt;bool&gt; results(num_threads)</code>. thread <em>i</em>, will store its result in <code>results[i]</code>.</p>
<p>The function <code>contains</code> takes a starting and ending iterators denoting a particular block of the vector. The reason we use a bool iterator for the <code>results</code> instead of, say, passing <code>result[i]</code> by reference is that the implementation of <code>std::vector&lt;bool&gt;</code> is a specialization of <code>std::vector</code>. In particular <code>operator[]</code> returns a value <strong>not</strong> a reference like the general implementation.</p>
<p>In the example below we search for a non-existent value to maximize the running time.</p>
<pre><code class="language-cpp"><span class="hljs-comment">/* Given a vector v of n integers:
* Write a function to test if v  
* contains a certain number at least once.
* Use as many threads as your hardware permits.
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">print_duration</span><span class="hljs-params">(T start, T end,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s)</span> </span>{
    <span class="hljs-keyword">auto</span> duration = <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::ratio&lt;<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>&gt;&gt;(end - start);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\nduration &quot;</span>&lt;&lt;s &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
<span class="hljs-comment">/* note that the range is
* a semi closed interval [first,last)
*/</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter,<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> IterBool&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">contains</span><span class="hljs-params">(Iter first, Iter last, T value,IterBool result)</span></span>;

<span class="hljs-comment">/* see the lecture notes for the reason we use
* an iterator for the bool instead of passing a bool
* variable by reference
*/</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter,<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> IterBool&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">contains</span><span class="hljs-params">(Iter first, Iter last, T value,IterBool result)</span> </span>{
	Iter itr = first;
	*result = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (itr != last) {
		<span class="hljs-keyword">if</span> (*itr == value) {
			*result = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">return</span>;
		}
		++itr;
	}
	<span class="hljs-keyword">return</span> ;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">/* choose size power of two */</span>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">25</span>;
	<span class="hljs-built_in">std</span>::random_device rd;
	<span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)</span></span>;
	<span class="hljs-comment">/* choosing a value that is NOT in the vector*/</span>
	<span class="hljs-keyword">int</span> value = <span class="hljs-number">12000</span>;


	<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-built_in">std</span>::generate(v.begin(), v.end(), [&amp;]() {<span class="hljs-keyword">return</span> dist(rd); });
	<span class="hljs-keyword">using</span> Iter = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator;
	<span class="hljs-comment">/* using the sequential STL std::any_of() */</span>
	<span class="hljs-keyword">auto</span> start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
	<span class="hljs-keyword">bool</span> res = <span class="hljs-built_in">std</span>::any_of(v.begin(), v.end(), [=](<span class="hljs-keyword">int</span> x) {<span class="hljs-keyword">return</span> x == value; });
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;sequential result = &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha &lt;&lt; res &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
	<span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
	print_duration(start, end, <span class="hljs-string">&quot;sequential &quot;</span>);

	<span class="hljs-comment">/* Using our implementation with the number of
	* threads equal to the hardware threads
	*/</span>
	<span class="hljs-keyword">int</span> num_threads = <span class="hljs-built_in">std</span>::thread::hardware_concurrency();
	<span class="hljs-keyword">int</span> block_size = n / num_threads;
	<span class="hljs-comment">/* store the result of each block in vector results */</span>
	<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">results</span><span class="hljs-params">(num_threads)</span></span>;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; mythreads;
	Iter begin = v.begin();
	<span class="hljs-keyword">auto</span> itr = results.begin();
	start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
	<span class="hljs-comment">/* declaring i as long long to avoid warning
	* when we use it for iterator arithmetics
	* since iterators on x64 are 8 bytes
	*/</span>
	<span class="hljs-comment">/* divide the input into blocks equal to the
	* number of threads
	*/</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) {
		<span class="hljs-comment">/* we can do such arithmetic because
		* vector iterators are random iterators
		*/</span>
		Iter first = begin + i * block_size;
		Iter last = begin + (i + <span class="hljs-number">1</span>) * block_size;
		mythreads.push_back(
			<span class="hljs-built_in">std</span>::thread(
				contains&lt;Iter, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">decltype</span>(itr)&gt;, first, last, value, itr)
		);
		++itr;
	}
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : mythreads)
		t.join();
	end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
	print_duration(start, end, <span class="hljs-string">&quot;multiple threads&quot;</span>);
	<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> identity = [](<span class="hljs-keyword">auto</span> r) {<span class="hljs-keyword">return</span> r; };
	<span class="hljs-comment">/* combine the results of blocks */</span>
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;multiple thread result &quot;</span>&lt;&lt;
		<span class="hljs-built_in">std</span>::any_of(results.begin(), results.end(),
			identity)&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	
}
</code></pre>
<h1>Example: parallel accumulate</h1>
<p>In its simplest form, <code>std::accumulate</code> adds( accumulates) all the values in a given range,<br />
including a <strong>supplied initial value</strong>. The default operation is <code>std::plus{}</code>, the first<br />
call to <code>std::accumulate</code> below can be written as<br />
<code>std::accumulate(v.begin(),v.end(),0,std::plus{})</code>. We can supply any <strong>binary</strong> operator,<br />
for example, in the second call below, we use <code>std::multiplies</code>.<br />
<strong>NOTE</strong>: if you are using a pre c++17 compiler you might need to supply template parameter<br />
for <code>std::multiplies{}</code>, e.g. <code>std::multiplies&lt;int&gt;{}</code>.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;
      <span class="hljs-built_in">std</span>::accumulate(v.begin(),v.end(),<span class="hljs-number">0</span>)
      &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
       <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;
      <span class="hljs-built_in">std</span>::accumulate(v.begin(),v.end(),<span class="hljs-number">1</span>,<span class="hljs-built_in">std</span>::multiplies{})
      &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p>You can try it <a href="https://godbolt.org/z/MosYY8">here</a>.</p>
<p>In general, <code>std::accumulate</code> works on a range of any type, as long as the supplied operation,<br />
is compatible with that type. While most of the time the operation passed to  <code>std::accumulate</code><br />
is associative, it is important to know that it performs a <strong>left fold</strong> operation, which, if the binary operation<br />
is not associative gives a different result than a <strong>right fold</strong>.<br />
For example, the midpoint operation below is <strong>not</strong> associative. While the function <code>foldr</code> and <code>foldl</code> are<br />
recursive, <code>std::accumulate</code> is not. It works similarly to <code>my_accumulate</code>.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Func = <span class="hljs-built_in">std</span>::plus&lt;T&gt; &gt;
T my_accumulate(Iter start, Iter end, T init, Func f = <span class="hljs-built_in">std</span>::plus&lt;T&gt;{}) {
    T result = init;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = start; itr != end; ++itr) {
        result =result+*itr;
    }
    <span class="hljs-keyword">return</span> result;
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Ts&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">foldr</span><span class="hljs-params">(Ts... params)</span> </span>{
    <span class="hljs-keyword">return</span> (params + ... + T{});
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> ...Ts&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">foldl</span><span class="hljs-params">(Ts... params)</span> </span>{
    <span class="hljs-keyword">return</span> (T{} + ... + params);
}
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mid</span> {</span>
    <span class="hljs-keyword">float</span> _x;
    mid(<span class="hljs-keyword">float</span> x=<span class="hljs-number">0</span>) :_x(x) {}
    mid <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> mid&amp; rhs) {
        <span class="hljs-keyword">return</span> mid((_x + rhs._x) / <span class="hljs-number">2</span>);
    }

};
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; u{ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> };
    <span class="hljs-built_in">std</span>::accumulate(u.begin(), u.end(), <span class="hljs-number">0</span>, <span class="hljs-built_in">std</span>::plus{});
    mid a{ <span class="hljs-number">1</span> }, b{ <span class="hljs-number">2</span> }, c{ <span class="hljs-number">3</span> };
    mid rr = foldr&lt;mid&gt;(a, b, c);
    mid lr = foldl&lt;mid&gt;(a, b, c);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; rr._x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; lr._x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;mid&gt; v{ a,b,c };
    <span class="hljs-keyword">auto</span> ar = <span class="hljs-built_in">std</span>::accumulate(v.begin(), v.end(),mid{});
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;my_accumulate(v.begin(), v.end(), mid{})._x&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ar._x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}

</code></pre>
<p>You can try the above code <a href="https://godbolt.org/z/qnWPf3">here</a>.</p>
<h2>Parallel accumulate</h2>
<p>In this section we will modify the <code>my_accumulate</code> function to run its operations in parallel.<br />
The basic idea is to divide the range into <em>m</em> subranges, where <em>m</em> is the number of threads we will run.<br />
Each thread will accumulate the values in its own range, and when all the threads are done the main thread<br />
will <strong>add</strong> the partial results.</p>
<p>Note that even though the <code>parallel_acc</code> function below applies<br />
an arbitrary function <em>f</em> on the subranges, the final result is the <em>sum</em> of those partial results.</p>
<pre><code class="language-cpp">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../include/utility.h&quot;</span></span>
<span class="hljs-keyword">using</span> Long = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;

<span class="hljs-comment">/* assume the vector size is a power of 2 */</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> NUMT=<span class="hljs-number">0</span>,<span class="hljs-keyword">typename</span> Iter,<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> Func&gt;
T parallel_acc(Iter first, Iter last, T init,Func f) {
	Long <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">std</span>::distance(first, last);
	
	Long num_threads = NUMT==<span class="hljs-number">0</span>?<span class="hljs-built_in">std</span>::thread::hardware_concurrency():NUMT;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Number of threads = &quot;</span> &lt;&lt; num_threads &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	Long block_size = length / num_threads;
	<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">results</span><span class="hljs-params">(num_threads )</span> </span>;
	<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; <span class="hljs-title">threads</span><span class="hljs-params">(num_threads )</span></span>;
	Iter block_start, block_end;
	<span class="hljs-keyword">for</span> (Long i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) {
		block_start = first + i * block_size;
		block_end = first+(i+<span class="hljs-number">1</span>)*block_size;
		threads[i] = <span class="hljs-built_in">std</span>::thread(
			[=](Iter s, Iter e, T&amp; r) {
				r = <span class="hljs-built_in">std</span>::accumulate(s, e, <span class="hljs-number">0.0</span>,f);
			},
			block_start,block_end,<span class="hljs-built_in">std</span>::ref(results[i])
		);
	}
	
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads)
		t.join();
	
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::accumulate(results.begin(), results.end(), init);

}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  n = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">25</span>;
	<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;
	<span class="hljs-built_in">std</span>::fill_n(v.begin(), n, <span class="hljs-number">1.0</span>);
	Duration d;
	<span class="hljs-keyword">double</span> r;
	TIMEIT(d
		,r=parallel_acc&lt;<span class="hljs-number">8</span>&gt;(v.begin(), v.end(), <span class="hljs-number">0.0</span>
			, [](<span class="hljs-keyword">double</span> acc, <span class="hljs-keyword">double</span> val) {<span class="hljs-keyword">return</span> acc += <span class="hljs-number">1.0</span> / (<span class="hljs-number">1</span> + val * val); }
		);
	)
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;result= &quot;</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;duration= &quot;</span> &lt;&lt; d.count() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
	<span class="hljs-comment">/* reference for std::accumulate
	* https://tinyurl.com/yd9b4qz8
	*/</span>
	TIMEIT(d
		, r=<span class="hljs-built_in">std</span>::accumulate(v.begin(), v.end(), <span class="hljs-number">0.0</span>
			, [](<span class="hljs-keyword">double</span> acc, <span class="hljs-keyword">double</span> val) {<span class="hljs-keyword">return</span> acc+=<span class="hljs-number">1.0</span> / (<span class="hljs-number">1</span> + val * val); }
		);
	)
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; d.count() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}


</code></pre>
<h1>Example: Computing PI</h1>
<p>In this section we will compute the value of PI both sequentially and in parallel.<br />
We will be using the below formula:</p>
&lt;div style="background-color:white"&gt;
&lt;img src="https://render.githubusercontent.com/render/math?math=\pi=\int_0^1\frac{dx}{1%2Bx^2}"&gt;&lt;/div&gt;
<p>The basic idea, as in the previous example, is to divide the interval [0,1] into subintervals and compute<br />
each subinterval in a different thread than combine the results.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../include/utility.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">double</span> stepsize,<span class="hljs-keyword">int</span> from,<span class="hljs-keyword">int</span> to,<span class="hljs-keyword">double</span>&amp; res)</span> </span>{
	<span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>, midpoint;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = from; i &lt; to; ++i) {
		midpoint = (i + <span class="hljs-number">0.5</span>) *stepsize;
		sum += <span class="hljs-number">1.0</span> / (<span class="hljs-number">1</span> + midpoint * midpoint);
	}
	<span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;
	res += <span class="hljs-number">4.0</span> *stepsize * sum;
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> <span class="hljs-keyword">hard_t</span></span>=<span class="hljs-number">2</span>&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">par_pi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">pow</span>, <span class="hljs-keyword">double</span>&amp; pi)</span> </span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num_steps = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">pow</span>;
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> block_size = num_steps / <span class="hljs-keyword">hard_t</span>;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; mythreads;
	<span class="hljs-keyword">double</span> results[<span class="hljs-keyword">hard_t</span>];
	<span class="hljs-keyword">double</span> dx = <span class="hljs-number">1.0</span> / (<span class="hljs-keyword">double</span>)num_steps;
	pi = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-keyword">hard_t</span>;++t) {
		mythreads.push_back(
			<span class="hljs-built_in">std</span>::thread(
				helper, dx, t * block_size, (t + <span class="hljs-number">1</span>) * block_size
				,<span class="hljs-built_in">std</span>::ref(results[t])
			)
		);
	}
	
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : mythreads)t.join();

	pi = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">hard_t</span>; ++i)
		pi += results[i];


}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq_pi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">pow</span>,<span class="hljs-keyword">double</span>&amp; pi)</span> </span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> num_steps = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">pow</span>;
	helper(<span class="hljs-number">1.0</span> / num_steps, <span class="hljs-number">0</span>, num_steps, pi);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	
	<span class="hljs-keyword">double</span> pi = <span class="hljs-number">0</span>;
	Duration d;
	TIMEIT(d
		, par_pi&lt;<span class="hljs-number">8</span>&gt;(<span class="hljs-number">28</span>, pi);
	)
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">20</span>) &lt;&lt; pi &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; d.count() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

}
</code></pre>
<h3>Computing sin(x)</h3>
<p>In this section we compute the sine function for every element in an array. In addition to using multithreading, we will be using the Advanced Vector Extensions (AVX512) for x86 processors.</p>
<p>First we start with computing the sine for only one element <em>x</em>. To accomplish that<br />
we use the Taylor expansion</p>
&lt;div style="background-color:white"&gt;
&lt;img src="https://render.githubusercontent.com/render/math?math=\sin(x)=x-\frac{x^3}{3!}%2B\frac{x^5}{5!}-\frac{x^7}{7!}%2B\cdots"&gt;&lt;/div&gt;

<p>Clearly the value of <code>sin(x)</code> depends on the number of terms we compute in the Taylor expansion.</p>
<h3>Computing sin for a single element</h3>
<pre><code class="language-cpp">
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">seq_sin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> terms,<span class="hljs-keyword">float</span> a)</span></span>{
    <span class="hljs-keyword">float</span> x=a;
    <span class="hljs-keyword">float</span> value=x;
    <span class="hljs-keyword">float</span> num=x*x*x;
    <span class="hljs-keyword">float</span> denom=<span class="hljs-number">6</span>;
    <span class="hljs-keyword">int</span> sign=<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;i&lt;=terms;++j){
        value+=sign*num*denom;
        num *=x*x;
        denom *=(<span class="hljs-number">2</span>*j+<span class="hljs-number">2</span>)*(<span class="hljs-number">2</span>*j+<span class="hljs-number">3</span>);
        sign *=<span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">return</span> value;
}
</code></pre>
<p>In the above we have used the property that we can compute the numerator and denominator of a term based on<br />
its previous values as follows</p>
<ol>
<li>Since all the terms are odd so numerator=previous numerator * x *x</li>
<li>The denominator contains the factorial of odd numbers so denominator=previous denominator* (2j+2)<em>(2j+3).<br />
For example 5!=3! * 4 * 5 and j=2 so 5!=3! * (2</em>j+2)<em>(2</em>j+3)</li>
<li>The sign of a term is the negation of the previous term</li>
</ol>
<h3>Computing the sin for a range</h3>
<p>We modify the previous code to handle the case where we want to compute the <em>sin</em> for a range of elements.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seq_sin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> terms, <span class="hljs-keyword">float</span>* a, <span class="hljs-keyword">float</span>* b)</span> </span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
		<span class="hljs-keyword">float</span> x = a[i];
		<span class="hljs-keyword">float</span> value = x;
		<span class="hljs-keyword">float</span> num = x * x * x;
		<span class="hljs-keyword">float</span> denom = <span class="hljs-number">6</span>;
		<span class="hljs-keyword">int</span> sign = <span class="hljs-number">-1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= terms; ++j) {
			value += sign * num / denom;
			num *= x * x;
			denom *= (<span class="hljs-number">2</span> * j + <span class="hljs-number">2</span>) * (<span class="hljs-number">2</span> * j + <span class="hljs-number">3</span>);
			sign *= <span class="hljs-number">-1</span>;
		}
		b[i] = value;
	}
}
</code></pre>
<h3>Multi-threaded version</h3>
<p>We can use multiple threads to compute the <em>sin</em>, or <strong>any</strong> function for that matter, for a range faster by subdividing the range between threads as we have done so far.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">multit_sin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> terms, <span class="hljs-keyword">float</span>* x, <span class="hljs-keyword">float</span>* y,F f)</span> </span>{
	<span class="hljs-keyword">int</span> num_threads = <span class="hljs-built_in">std</span>::thread::hardware_concurrency();
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; mythreads;
	<span class="hljs-keyword">int</span> block_size = n / num_threads;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) {

			mythreads.push_back(
				<span class="hljs-built_in">std</span>::thread(f, block_size, terms, x, y)
			);
			x += block_size;
			y += block_size;
		}
	
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i)
		mythreads[i].join();

}
</code></pre>
<h3>USing AVX512</h3>
<p>The Advanced Vector Extension (AVX) are extensions to the x86 instruction set which allow the CPU to perform a<br />
single instruction on multiple data (SIMD). In this section we use the AVX512 which allow us to compute a single<br />
instruction on 512 bits of data. For example, for a float which is typically 4 bytes, an AVX can compute the same<br />
operation on 16 floats at the same time. It is important to note that, in our case, we don't expect a x16 speedup since<br />
there are other factors that come into play like memory transfers and cache invalidation.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vector_sin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> terms, <span class="hljs-keyword">float</span>* a, <span class="hljs-keyword">float</span>* b)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; LOAD; ++k) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">16</span>)
		{
			__m512 x = _mm512_load_ps(&amp;a[i]);
			__m512 value = x;
			__m512 numer = _mm512_mul_ps(x, _mm512_mul_ps(x, x));<span class="hljs-comment">//x^3</span>
			__m512 denom = _mm512_set1_ps(<span class="hljs-number">6</span>);<span class="hljs-comment">// 3 factorial</span>
			<span class="hljs-keyword">int</span> sign = <span class="hljs-number">-1</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= terms; j++)
			{
				<span class="hljs-comment">// value += sign * numer / denom</span>
				__m512 tmp = _mm512_div_ps(_mm512_mul_ps(_mm512_set1_ps(sign), numer), denom);
				value = _mm512_add_ps(value, tmp);
				numer = _mm512_mul_ps(numer, _mm512_mul_ps(x, x));
				denom = _mm512_mul_ps(denom, _mm512_set1_ps((<span class="hljs-number">2</span> * j + <span class="hljs-number">2</span>) * (<span class="hljs-number">2</span> * j + <span class="hljs-number">3</span>)));
				sign *= <span class="hljs-number">-1</span>;
			}
			_mm512_store_ps(&amp;b[i], value);
		}
	}
}

</code></pre>
<h3>Combining both</h3>
<p>Since the multi-threaded version can accept any function we can passed the AVX512 function. In fact this<br />
combination gives us the biggest speedup. Without going into too much details, since the computation is split over multiple cores, cache invalidation is minimized.</p>
</section>
<script>!function(){"use strict";const t="marpitSVGPolyfill:setZoomFactor,",e=Symbol();let r,o;function n(n){const i="object"==typeof n&&n.target||document,a="object"==typeof n?n.zoom:n;window[e]||(Object.defineProperty(window,e,{configurable:!0,value:!0}),window.addEventListener("message",(({data:e,origin:r})=>{if(r===window.origin)try{if(e&&"string"==typeof e&&e.startsWith(t)){const[,t]=e.split(","),r=Number.parseFloat(t);Number.isNaN(r)||(o=r)}}catch(t){console.error(t)}})));let l=!1;Array.from(i.querySelectorAll("svg[data-marpit-svg]"),(t=>{var e,n,i,s;t.style.transform||(t.style.transform="translateZ(0)");const c=a||o||t.currentScale||1;r!==c&&(r=c,l=c);const d=t.getBoundingClientRect(),{length:u}=t.children;for(let r=0;r<u;r+=1){const o=t.children[r],a=o.getScreenCTM();if(a){const t=null!==(n=null===(e=o.x)||void 0===e?void 0:e.baseVal.value)&&void 0!==n?n:0,r=null!==(s=null===(i=o.y)||void 0===i?void 0:i.baseVal.value)&&void 0!==s?s:0,l=o.firstElementChild,{style:u}=l;u.transformOrigin||(u.transformOrigin=`${-t}px ${-r}px`),u.transform=`scale(${c}) matrix(${a.a}, ${a.b}, ${a.c}, ${a.d}, ${a.e-d.left}, ${a.f-d.top}) translateZ(0.0001px)`}}})),!1!==l&&Array.from(i.querySelectorAll("iframe"),(({contentWindow:e})=>{null==e||e.postMessage(`${t}${l}`,"null"===window.origin?"*":window.origin)}))}r=1,o=void 0;const i=(t,e,r)=>{if(t.getAttribute(e)!==r)return t.setAttribute(e,r),!0};function a({once:t=!1,target:e=document}={}){const r="Apple Computer, Inc."===navigator.vendor?[n]:[];let o=!t;const a=()=>{for(const t of r)t({target:e});!function(t=document){Array.from(t.querySelectorAll('svg[data-marp-fitting="svg"]'),(t=>{var e;const r=t.firstChild,o=r.firstChild,{scrollWidth:n,scrollHeight:a}=o;let l,s=1;if(t.hasAttribute("data-marp-fitting-code")&&(l=null===(e=t.parentElement)||void 0===e?void 0:e.parentElement),t.hasAttribute("data-marp-fitting-math")&&(l=t.parentElement),l){const t=getComputedStyle(l),e=Math.ceil(l.clientWidth-parseFloat(t.paddingLeft||"0")-parseFloat(t.paddingRight||"0"));e&&(s=e)}const c=Math.max(n,s),d=Math.max(a,1),u=`0 0 ${c} ${d}`;i(r,"width",`${c}`),i(r,"height",`${d}`),i(t,"preserveAspectRatio",getComputedStyle(t).getPropertyValue("--preserve-aspect-ratio")||"xMinYMin meet"),i(t,"viewBox",u)&&t.classList.toggle("__reflow__")}))}(e),o&&window.requestAnimationFrame(a)};return a(),()=>{o=!1}}const l=Symbol(),s=document.currentScript;((t=document)=>{if("undefined"==typeof window)throw new Error("Marp Core's browser script is valid only in browser context.");if(t[l])return t[l];const e=a({target:t}),r=()=>{e(),delete t[l]};Object.defineProperty(t,l,{configurable:!0,value:r})})(s?s.getRootNode():document)}();
</script></foreignObject></svg></div><div class="bespoke-marp-note" data-index="0" tabindex="0"><p>$$sin(x)=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\ldots $$</p></div><script>!function(){"use strict";var e=function(e,t){var n,r=1===(e.parent||e).nodeType?e.parent||e:document.querySelector(e.parent||e),s=[].filter.call("string"==typeof e.slides?r.querySelectorAll(e.slides):e.slides||r.children,(function(e){return"SCRIPT"!==e.nodeName})),a={},i=function(e,t){return(t=t||{}).index=s.indexOf(e),t.slide=e,t},o=function(e,t){a[e]=(a[e]||[]).filter((function(e){return e!==t}))},l=function(e,t){return(a[e]||[]).reduce((function(e,n){return e&&!1!==n(t)}),!0)},c=function(e,t){s[e]&&(n&&l("deactivate",i(n,t)),n=s[e],l("activate",i(n,t)))},d=function(e,t){var r=s.indexOf(n)+e;l(e>0?"next":"prev",i(n,t))&&c(r,t)},u={off:o,on:function(e,t){return(a[e]||(a[e]=[])).push(t),o.bind(null,e,t)},fire:l,slide:function(e,t){if(!arguments.length)return s.indexOf(n);l("slide",i(s[e],t))&&c(e,t)},next:d.bind(null,1),prev:d.bind(null,-1),parent:r,slides:s,destroy:function(e){l("destroy",i(n,e)),a={}}};return(t||[]).forEach((function(e){e(u)})),n||c(0),u};function t(e){e.parent.classList.add("bespoke-marp-parent"),e.slides.forEach((e=>e.classList.add("bespoke-marp-slide"))),e.on("activate",(t=>{const n=t.slide,r=!n.classList.contains("bespoke-marp-active");e.slides.forEach((e=>{e.classList.remove("bespoke-marp-active"),e.setAttribute("aria-hidden","true")})),n.classList.add("bespoke-marp-active"),n.removeAttribute("aria-hidden"),r&&(n.classList.add("bespoke-marp-active-ready"),document.body.clientHeight,n.classList.remove("bespoke-marp-active-ready"))}))}function n(e){let t=0,n=0;Object.defineProperty(e,"fragments",{enumerable:!0,value:e.slides.map((e=>[null,...e.querySelectorAll("[data-marpit-fragment]")]))});const r=r=>void 0!==e.fragments[t][n+r],s=(r,s)=>{t=r,n=s,e.fragments.forEach(((e,t)=>{e.forEach(((e,n)=>{if(null==e)return;const a=t<r||t===r&&n<=s;e.setAttribute("data-bespoke-marp-fragment",a?"active":"inactive"),t===r&&n===s?e.setAttribute("data-bespoke-marp-current-fragment","current"):e.removeAttribute("data-bespoke-marp-current-fragment")}))})),e.fragmentIndex=s;const a={slide:e.slides[r],index:r,fragments:e.fragments[r],fragmentIndex:s};e.fire("fragment",a)};e.on("next",(({fragment:a=!0})=>{if(a){if(r(1))return s(t,n+1),!1;const a=t+1;e.fragments[a]&&s(a,0)}else{const r=e.fragments[t].length;if(n+1<r)return s(t,r-1),!1;const a=e.fragments[t+1];a&&s(t+1,a.length-1)}})),e.on("prev",(({fragment:a=!0})=>{if(r(-1)&&a)return s(t,n-1),!1;const i=t-1;e.fragments[i]&&s(i,e.fragments[i].length-1)})),e.on("slide",(({index:t,fragment:n})=>{let r=0;if(void 0!==n){const s=e.fragments[t];if(s){const{length:e}=s;r=-1===n?e-1:Math.min(Math.max(n,0),e-1)}}s(t,r)})),s(0,0)}
/*!
* screenfull
* v5.1.0 - 2020-12-24
* (c) Sindre Sorhus; MIT License
*/
var r,s=(function(e){!function(){var t="undefined"!=typeof window&&void 0!==window.document?window.document:{},n=e.exports,r=function(){for(var e,n=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","webkitCancelFullScreen","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"],["msRequestFullscreen","msExitFullscreen","msFullscreenElement","msFullscreenEnabled","MSFullscreenChange","MSFullscreenError"]],r=0,s=n.length,a={};r<s;r++)if((e=n[r])&&e[1]in t){for(r=0;r<e.length;r++)a[n[0][r]]=e[r];return a}return!1}(),s={change:r.fullscreenchange,error:r.fullscreenerror},a={request:function(e,n){return new Promise(function(s,a){var i=function(){this.off("change",i),s()}.bind(this);this.on("change",i);var o=(e=e||t.documentElement)[r.requestFullscreen](n);o instanceof Promise&&o.then(i).catch(a)}.bind(this))},exit:function(){return new Promise(function(e,n){if(this.isFullscreen){var s=function(){this.off("change",s),e()}.bind(this);this.on("change",s);var a=t[r.exitFullscreen]();a instanceof Promise&&a.then(s).catch(n)}else e()}.bind(this))},toggle:function(e,t){return this.isFullscreen?this.exit():this.request(e,t)},onchange:function(e){this.on("change",e)},onerror:function(e){this.on("error",e)},on:function(e,n){var r=s[e];r&&t.addEventListener(r,n,!1)},off:function(e,n){var r=s[e];r&&t.removeEventListener(r,n,!1)},raw:r};r?(Object.defineProperties(a,{isFullscreen:{get:function(){return Boolean(t[r.fullscreenElement])}},element:{enumerable:!0,get:function(){return t[r.fullscreenElement]}},isEnabled:{enumerable:!0,get:function(){return Boolean(t[r.fullscreenEnabled])}}}),n?e.exports=a:window.screenfull=a):n?e.exports={isEnabled:!1}:window.screenfull={isEnabled:!1}}()}(r={exports:{}},r.exports),r.exports);function a(e){e.fullscreen=()=>{s.isEnabled&&s.toggle(document.body)},document.addEventListener("keydown",(t=>{70!==t.which&&122!==t.which||t.altKey||t.ctrlKey||t.metaKey||!s.isEnabled||(e.fullscreen(),t.preventDefault())}))}function i(e=2e3){return t=>{let n;function r(){n&&clearTimeout(n),n=setTimeout((()=>{t.parent.classList.add("bespoke-marp-inactive"),t.fire("marp-inactive")}),e),t.parent.classList.contains("bespoke-marp-inactive")&&(t.parent.classList.remove("bespoke-marp-inactive"),t.fire("marp-active"))}document.addEventListener("mousedown",r),document.addEventListener("mousemove",r),document.addEventListener("touchend",r),setTimeout(r,0)}}const o=["AUDIO","BUTTON","INPUT","SELECT","TEXTAREA","VIDEO"];function l(e){e.parent.addEventListener("keydown",(e=>{if(!e.target)return;const t=e.target;(o.includes(t.nodeName)||"true"===t.contentEditable)&&e.stopPropagation()}))}function c(e){window.addEventListener("load",(()=>{for(const t of e.slides){const e=t.querySelector("[data-marp-fitting]")?"":"hideable";t.setAttribute("data-bespoke-marp-load",e)}}))}var d;function u({interval:e=200}={}){return t=>{document.addEventListener("keydown",(e=>{if(32===e.which&&e.shiftKey)t.prev();else if(33===e.which||37===e.which||38===e.which)t.prev({fragment:!e.shiftKey});else if(32!==e.which||e.shiftKey)if(34===e.which||39===e.which||40===e.which)t.next({fragment:!e.shiftKey});else if(35===e.which)t.slide(t.slides.length-1,{fragment:-1});else{if(36!==e.which)return;t.slide(0)}else t.next();e.preventDefault()}));let n,r,s=0;t.parent.addEventListener("wheel",(a=>{let i=!1;const o=(e,t)=>{e&&(i=i||function(e,t){return function(e,t){const n=t===d.X?"Width":"Height";return e[`client${n}`]<e[`scroll${n}`]}(e,t)&&function(e,t){const{overflow:n}=e,r=e[`overflow${t}`];return"auto"===n||"scroll"===n||"auto"===r||"scroll"===r}(getComputedStyle(e),t)}(e,t)),(null==e?void 0:e.parentElement)&&o(e.parentElement,t)};if(0!==a.deltaX&&o(a.target,d.X),0!==a.deltaY&&o(a.target,d.Y),i)return;a.preventDefault(),r&&clearTimeout(r),r=setTimeout((()=>{n=0}),e);const l=Date.now()-s<e,c=Math.sqrt(Math.pow(a.deltaX,2)+Math.pow(a.deltaY,2)),u=c<=n;if(n=c,l||u)return;let f;(a.deltaX>0||a.deltaY>0)&&(f="next"),(a.deltaX<0||a.deltaY<0)&&(f="prev"),f&&(t[f](),s=Date.now())}))}}!function(e){e.X="X",e.Y="Y"}(d||(d={}));const f=(...e)=>history.replaceState(...e),m="data-bespoke-view";var p;!function(e){e.Normal="",e.Presenter="presenter",e.Next="next"}(p||(p={}));const h=(e,{protocol:t,host:n,pathname:r,hash:s}=location)=>{const a=e.toString();return`${t}//${n}${r}${a?"?":""}${a}${s}`},g=()=>{switch(document.body.getAttribute(m)){case p.Normal:return p.Normal;case p.Presenter:return p.Presenter;case p.Next:return p.Next;default:throw new Error("View mode is not assigned.")}},v=e=>new URLSearchParams(location.search).get(e),b=(e,t={})=>{const n=Object.assign({location:location,setter:f},t),r=new URLSearchParams(n.location.search);for(const t of Object.keys(e)){const n=e[t];"string"==typeof n?r.set(t,n):r.delete(t)}try{n.setter(null,document.title,h(r,n.location))}catch(e){console.error(e)}},w={available:(()=>{try{return localStorage.setItem("bespoke-marp","bespoke-marp"),localStorage.removeItem("bespoke-marp"),!0}catch(e){return console.warn("Warning: Using localStorage is restricted in the current host so some features may not work."),!1}})(),get:e=>{try{return localStorage.getItem(e)}catch(e){return null}},set:(e,t)=>{try{return localStorage.setItem(e,t),!0}catch(e){return!1}},remove:e=>{try{return localStorage.removeItem(e),!0}catch(e){return!1}}};function y(e=".bespoke-marp-osc"){const t=document.querySelector(e);if(!t)return()=>{};const n=(e,n)=>{t.querySelectorAll(`[data-bespoke-marp-osc=${JSON.stringify(e)}]`).forEach(n)};return s.isEnabled||n("fullscreen",(e=>e.style.display="none")),w.available||n("presenter",(e=>{e.disabled=!0,e.title="Presenter view is disabled due to restricted localStorage."})),e=>{t.addEventListener("click",(t=>{if(t.target instanceof HTMLElement){const{bespokeMarpOsc:n}=t.target.dataset;switch(n&&t.target.blur(),n){case"next":e.next({fragment:!t.shiftKey});break;case"prev":e.prev({fragment:!t.shiftKey});break;case"fullscreen":"function"==typeof e.fullscreen&&s.isEnabled&&e.fullscreen();break;case"presenter":e.openPresenterView()}}})),e.parent.appendChild(t),e.on("activate",(({index:t})=>{n("page",(n=>n.textContent=`Page ${t+1} of ${e.slides.length}`))})),e.on("fragment",(({index:t,fragments:r,fragmentIndex:s})=>{n("prev",(e=>e.disabled=0===t&&0===s)),n("next",(n=>n.disabled=t===e.slides.length-1&&s===r.length-1))})),e.on("marp-active",(()=>t.removeAttribute("aria-hidden"))),e.on("marp-inactive",(()=>t.setAttribute("aria-hidden","true"))),s.isEnabled&&s.onchange((()=>n("fullscreen",(e=>e.classList.toggle("exit",s.isEnabled&&s.isFullscreen)))))}}function x(){const e=Math.max(Math.floor(.85*window.innerWidth),640),t=Math.max(Math.floor(.85*window.innerHeight),360);return window.open(this.presenterUrl,`bespoke-marp-presenter-${this.syncKey}`,`width=${e},height=${t},menubar=no,toolbar=no`)}function k(){const e=new URLSearchParams(location.search);return e.set("view","presenter"),e.set("sync",this.syncKey),h(e)}var E=["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];let L=e=>String(e).replace(/[&<>"']/g,(e=>`&${S[e]};`)),S={"&":"amp","<":"lt",">":"gt",'"':"quot","'":"apos"},I="dangerouslySetInnerHTML",P={className:"class",htmlFor:"for"},M={};function N(e,t){let n=[],r="";t=t||{};for(let e=arguments.length;e-- >2;)n.push(arguments[e]);if("function"==typeof e)return t.children=n.reverse(),e(t);if(e){if(r+="<"+e,t)for(let e in t)!1!==t[e]&&null!=t[e]&&e!==I&&(r+=` ${P[e]?P[e]:L(e)}="${L(t[e])}"`);r+=">"}if(-1===E.indexOf(e)){if(t[I])r+=t[I].__html;else for(;n.length;){let e=n.pop();if(e)if(e.pop)for(let t=e.length;t--;)n.push(e[t]);else r+=!0===M[e]?e:L(e)}r+=e?`</${e}>`:""}return M[r]=!0,r}const F=({children:e})=>N(null,null,...e),$="bespoke-marp-presenter-container",O="bespoke-marp-presenter-next",q="bespoke-marp-presenter-next-container",C="bespoke-marp-presenter-note-container",T="bespoke-marp-presenter-info-container",A="bespoke-marp-presenter-info-page",K="bespoke-marp-presenter-info-page-text",j="bespoke-marp-presenter-info-page-prev",R="bespoke-marp-presenter-info-page-next",U="bespoke-marp-presenter-info-time",D="bespoke-marp-presenter-info-timer";function V(e){const{title:t}=document;document.title="[Presenter view]"+(t?` - ${t}`:"");const n={},r=e=>(n[e]=n[e]||document.querySelector(`.${e}`),n[e]);document.body.appendChild((e=>{const t=document.createElement("div");return t.className=$,t.appendChild(e),t.insertAdjacentHTML("beforeend",N(F,null,N("div",{class:q},N("iframe",{class:O,src:"?view=next"})),N("div",{class:C}),N("div",{class:T},N("div",{class:A},N("button",{class:j,tabindex:"-1",title:"Previous"},"Previous"),N("span",{class:K}),N("button",{class:R,tabindex:"-1",title:"Next"},"Next")),N("time",{class:U,title:"Current time"}),N("div",{class:D})))),t})(e.parent)),(e=>{r(q).addEventListener("click",(()=>e.next()));const t=r(O),n=(s=t,(e,t)=>{var n;return null===(n=s.contentWindow)||void 0===n?void 0:n.postMessage(`navigate:${e},${t}`,"null"===window.origin?"*":window.origin)});var s;t.addEventListener("load",(()=>{r(q).classList.add("active"),n(e.slide(),e.fragmentIndex),e.on("fragment",(({index:e,fragmentIndex:t})=>n(e,t)))}));const a=document.querySelectorAll(".bespoke-marp-note");a.forEach((e=>{e.addEventListener("keydown",(e=>e.stopPropagation())),r(C).appendChild(e)})),e.on("activate",(()=>a.forEach((t=>t.classList.toggle("active",t.dataset.index==e.slide()))))),e.on("activate",(({index:t})=>{r(K).textContent=`${t+1} / ${e.slides.length}`}));const i=r(j),o=r(R);i.addEventListener("click",(t=>{i.blur(),e.prev({fragment:!t.shiftKey})})),o.addEventListener("click",(t=>{o.blur(),e.next({fragment:!t.shiftKey})})),e.on("fragment",(({index:t,fragments:n,fragmentIndex:r})=>{i.disabled=0===t&&0===r,o.disabled=t===e.slides.length-1&&r===n.length-1}));const l=()=>r(U).textContent=(new Date).toLocaleTimeString();l(),setInterval(l,250)})(e)}function X(e){const t=g();return t===p.Next&&e.appendChild(document.createElement("span")),e=>{t===p.Normal&&function(e){if(!(e=>e.syncKey&&"string"==typeof e.syncKey)(e))throw new Error("The current instance of Bespoke.js is invalid for Marp bespoke presenter plugin.");Object.defineProperties(e,{openPresenterView:{enumerable:!0,value:x},presenterUrl:{enumerable:!0,get:k}}),w.available&&document.addEventListener("keydown",(t=>{80!==t.which||t.altKey||t.ctrlKey||t.metaKey||(t.preventDefault(),e.openPresenterView())}))}(e),t===p.Presenter&&V(e),t===p.Next&&function(e){const t=t=>{if(t.origin!==window.origin)return;const[n,r]=t.data.split(":");if("navigate"===n){const[t,n]=r.split(",");let s=Number.parseInt(t,10),a=Number.parseInt(n,10)+1;a>=e.fragments[s].length&&(s+=1,a=0),e.slide(s,{fragment:a})}};window.addEventListener("message",t),e.on("destroy",(()=>window.removeEventListener("message",t)))}(e)}}function Y(e){e.on("activate",(t=>{document.querySelectorAll(".bespoke-progress-parent > .bespoke-progress-bar").forEach((n=>{n.style.flexBasis=100*t.index/(e.slides.length-1)+"%"}))}))}const B=e=>{const t=Number.parseInt(e,10);return Number.isNaN(t)?null:t};function z(e={}){const t=Object.assign({history:!0},e);return e=>{let n=!0;const r=e=>{const t=n;try{return n=!0,e()}finally{n=t}},s=(t={fragment:!0})=>{((t,n)=>{const{fragments:r,slides:s}=e,a=Math.max(0,Math.min(t,s.length-1)),i=Math.max(0,Math.min(n||0,r[a].length-1));a===e.slide()&&i===e.fragmentIndex||e.slide(a,{fragment:i})})((B(location.hash.slice(1))||1)-1,t.fragment?B(v("f")||""):null)};e.on("fragment",(({index:e,fragmentIndex:r})=>{n||b({f:0===r||r.toString()},{location:Object.assign(Object.assign({},location),{hash:`#${e+1}`}),setter:(...e)=>t.history?history.pushState(...e):history.replaceState(...e)})})),setTimeout((()=>{s(),window.addEventListener("hashchange",(()=>r((()=>{s({fragment:!1}),b({f:void 0})})))),window.addEventListener("popstate",(()=>{n||r((()=>s()))})),n=!1}),0)}}let H;function W(e={}){const t=e.key||((e=21)=>{let t="",n=crypto.getRandomValues(new Uint8Array(e));for(;e--;){let r=63&n[e];t+=r<36?r.toString(36):r<62?(r-26).toString(36).toUpperCase():r<63?"_":"-"}return t})(),n=`bespoke-marp-sync-${t}`,r=()=>{const e=w.get(n);return e?JSON.parse(e):Object.create(null)},s=e=>{const t=r(),s=Object.assign(Object.assign({},t),e(t));return w.set(n,JSON.stringify(s)),s};return s((e=>({reference:(e.reference||0)+1}))),e=>{Object.defineProperty(e,"syncKey",{value:t,enumerable:!0});let a=!0;setTimeout((()=>{e.on("fragment",(e=>{a&&s((()=>({index:e.index,fragmentIndex:e.fragmentIndex})))}))}),0),window.addEventListener("storage",(t=>{if(t.key===n&&t.oldValue&&t.newValue){const n=JSON.parse(t.oldValue),r=JSON.parse(t.newValue);if(n.index!==r.index||n.fragmentIndex!==r.fragmentIndex)try{a=!1,e.slide(r.index,{fragment:r.fragmentIndex})}finally{a=!0}}})),e.on("destroy",(()=>{const{reference:e}=r();void 0===e||e<=1?w.remove(n):s((()=>({reference:e-1})))}))}}function J({slope:e=Math.tan(-35*Math.PI/180),swipeThreshold:t=30}={}){return n=>{let r;const s=n.parent,a=e=>{const t=s.getBoundingClientRect();return{x:e.pageX-(t.left+t.right)/2,y:e.pageY-(t.top+t.bottom)/2}};s.addEventListener("touchstart",(e=>{r=1===e.touches.length?a(e.touches[0]):void 0}),{passive:!0}),s.addEventListener("touchmove",(e=>{if(r)if(1===e.touches.length){e.preventDefault();const t=a(e.touches[0]),n=t.x-r.x,s=t.y-r.y;r.delta=Math.sqrt(Math.pow(Math.abs(n),2)+Math.pow(Math.abs(s),2)),r.radian=Math.atan2(n,s)}else r=void 0})),s.addEventListener("touchend",(s=>{if(r){if(r.delta&&r.delta>=t&&r.radian){let t=r.radian-e;t=(t+Math.PI)%(2*Math.PI)-Math.PI,n[t<0?"next":"prev"](),s.stopPropagation()}r=void 0}}),{passive:!0})}}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function _(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}const G=()=>(void 0===H&&(H="wakeLock"in navigator&&navigator.wakeLock),H),Q=()=>_(void 0,void 0,void 0,(function*(){const e=G();if(e)try{const t=yield e.request("screen");return t.addEventListener("release",(()=>{console.debug("[Marp CLI] Wake Lock was released")})),console.debug("[Marp CLI] Wake Lock is active"),t}catch(e){console.warn(e)}return null}));function Z(){return _(this,void 0,void 0,(function*(){if(!G())return;let e;const t=()=>{e&&"visible"===document.visibilityState&&Q()};return document.addEventListener("visibilitychange",t),document.addEventListener("fullscreenchange",t),e=yield Q(),e}))}const ee=[p.Normal,p.Presenter,p.Next];!function(r=document.getElementById("p")){document.body.setAttribute(m,(()=>{switch(v("view")){case"next":return p.Next;case"presenter":return p.Presenter;default:return p.Normal}})());const s=(e=>{const t=v(e);return b({[e]:void 0}),t})("sync")||void 0,o=!1,d=!0,f=e(r,((...e)=>{const t=ee.findIndex((e=>g()===e));if(t<0)throw new Error("Invalid view");return e.map((([e,n])=>e[t]&&n)).filter((e=>e))})([[d,d,o],W({key:s})],[[d,d,d],X(r)],[[d,d,o],l],[[d,d,d],t],[[d,o,o],i()],[[d,d,d],c],[[d,d,d],z({history:!1})],[[d,d,o],u()],[[d,d,o],a],[[d,o,o],Y],[[d,d,o],J()],[[d,o,o],y()],[[d,d,d],n],[[d,d,o],Z]));window.addEventListener("beforeunload",(()=>b({sync:f.syncKey}))),window.addEventListener("unload",(()=>f.destroy()))}()}();</script></body></html>